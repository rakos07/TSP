\Chapter{Egy étterem, egy futár, több kiszállítás esete}

\Section{A probléma megfogalmazása}

Egy étterem, egy futár és több kiszállításnál az adott helyzet egészen visszavezethető a klasszikus utazó ügynök problémához.
A futár elindul az étteremből, érinteni kell az összes kiszállítási pontot, valamint vissza kell érkeznie az étterembe, mindezt úgy, hogy a lehető legkisebb utat tegye meg.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{images/Simpletsp.png}
\caption{Egy étterem, egy futár, több kiszállítás modellje}
\label{fig:model2}
\end{figure}

\Section{A probléma megoldása}

Gibbs-faktor

A Gibbs-faktor reprezentálja az új állapotba való áttérés valószínűségét.\\

A klasszikus utazó ügynök probléma matematikai megfogalmazása kiszállítási kritériumokra levetítve.
Az egy ügynökös utazó ügynök probléma esetén jelölje V a csúcsok (pontok) halmazát, $x_{i,j}$ azt, hogy az $i.$ pontból megy-e közvetlenül út a $j.$ pontba. Az $x_{i,j}$ 1, ha útvonal köti össze a két pontot, különben 0:
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{images/1tsp.png}
\end{figure}

A $d_{i,j}$ jelöli az $i.$ és a $j.$ pont távolságát, $n$ pedig a pontok számát. A célfüggvény az alábbi:
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{images/2tsp.png}
\end{figure}

A célfüggvénnyel magát a megtett távolságot szeretnénk optimalizálni. A pontba csak egy él fut be, tehát
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{images/3tsp.png}
\end{figure}

Valamint, minden pontba csakis egy él távozik, ezek szerint
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{images/4tsp.png}
\end{figure}

A sorrendiség a következő feltétel alapján érényesül
\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{images/5tsp.png}
\end{figure}

Itt $u_{i}$ az $i.$ pont, $u_{j}$ a $j.$ pont látogatási indexe, ahol az $i.$ pontot hamarabb keresi fel az futár mint a $j.$-ot

\Section{A megoldás implementálása}

Összes lehetséges út:
\[
\dfrac{(n-1)!}{2}
\]
Ezek közül kell választanunk, ez ugyanis a Hamilton-körök száma az n pontú teljes gráfban.

A képlet csak $n > 2$ esetén működik.

Ezen importok szükségesek a szimuláció futtatásához

\begin{python}
from scipy.spatial import distance_matrix
\end{python}

A cél az, hogy listát készítsünk a pontokról, amelyek mindegyike két koordinátát tartalmaz $(x, y)$, amelyek 0 és 100 közötti véletlen egész számokként kerülnek kiválasztásra. Jelen esetben 10 ilyen pont lesz.

\begin{python}
points = [random.sample(range(100), 2) for x in range(10)]
\end{python}

A pontok közötti távolságok kimutatását így oldottam meg.

\begin{python}
data = Points
points = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
df = pd.DataFrame(data, columns=['xcord', 'ycord'], index=points)
pd.DataFrame(
	distance_matrix(
		df.values, 
		df.values
	), 
	index=df.index,
	columns=df.index
)
\end{python}

Ezt a kimenetett adta válaszul.

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{images/table.png}
\caption{Pontok közötti távolságmátrix}
\label{fig:kimenet}
\end{figure}

Inicializáljuk a pointCount értékét 10-re, ennyi helyre kell a futárnak eljutnia.

\begin{python}
pointCount = 10
\end{python}

A travel egy adott számból álló lista (jelen esetben 10 számból áll), amely a pontok meglátogatására utal. Feltételezzük, hogy zárt hurokra van szükség, így az utolsó pont autómatikusan csatlakozik az elsőhöz.


\begin{python}
travel = random.sample(range(pointCount), pointCount);}
\end{python}

Elindítunk egy ciklust az adott értékekkel


\begin{python}
for tlp in numpy.logspace(0, 5, num = 100000)[::-1]:
\end{python}


Két pont véletlenszerű cseréjével új új utat képzünk. Úgy valósítom meg, hogy választok két számot az i-t és a j-t. Összeállítom a newTravel-t a régi travel másolásával az i indexig, majd összefűzöm a j-edik travelel-t és egészen folytatom addig, amíg a j nem éri el az i-edik pontot, majd befejezem a travel többi részét.


\begin{python}
[i, j] = sorted(random.sample(range(pointCount), 2));
newTravel = travel[:i] + 
			travel[j:j + 1] + 
			travel[i + 1:j] + 
			travel[i:i + 1] + 
			travel[j + 1:]
\end{python}


Ha az if értéke igaz akkor a travel megkapja a newTravel értékét, az előzöekben említett csere miatt ez már változott. Az elképzelés az, hogy minimalizálni szeretnénk a pontok közti távolságok költségének összegét. Ehhez a Gibb-s faktor-t használtam fel, aminek lényege, az új állapotba való átmenet valószínűsége. Csak az i-edik és j-edik pontok közötti távolságokat szükséges összegezni, mivel a többi távolság ugyanaz mint a travel-ben mint a newTravel-ben egyaránt. Ha a faktor > 1 akkor az új költség alacsonyabb, travel megkapja a newTravel értékét.


\begin{python}
traveld = sum([
	math.sqrt(
		sum([(
			(
			  (points[travel[(k + 1) % pointCount]][d]) - 
			  (points[travel[k % pointCount]][d])
			) **  2
		) for d in [0, 1]])
	) for k in [j, j - 1, i, i - 1]
])
newTraveld = sum([
	math.sqrt(
		sum([(
			(
			  (points[newTravel[(k + 1) % pointCount]][d]) - 
			  (points[newTravel[k % pointCount]][d])) 
			** 2
		) for d in [0, 1]])
	) for k in [j, j - 1, i, i - 1]
])
    if math.exp((traveld - newTraveld) / tlp) > random.random():
        travel = copy.copy(newTravel);
\end{python}        


Az algoritmus végeztével már csak meg kell jeleníteni a kívánt pontokat, ez kirajzol egy gráfot, amely optimális utat ad. Ehhez a pyplot libary-t használtam


\begin{python}
plt.plot(
	[points[
		travel[i % pointCount]][0] for i in range(pointCount + 1)
	], 
	[points[
		travel[i % pointCount]][1] for i in range(pointCount + 1)
	], 
	'xb-'
)
plt.show()
\end{python}

\Section{A megoldás tesztelése}

A pointCount állításával adhatjuk meg, hogy hány helyre is kell mennie a futárnak. Ennek módosításával több lefuttatott teszt után is megfigyelhető, hogy az összehasonlítások száma 65 ezer és 75 ezer között mozog. Egytől egyig az optimális utat adták. Mivel véletlenszerű számok összehasonlításán alapszik az algoritmus ezáltal az összehasonlítások száma igen magas, viszont stagnál bizonyos értékek között.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{images/5.png}
\caption{5 kiszállítási hely esetén az összehasonlítások száma: 74 434}
\label{fig:tsp5location}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{images/10.png}
\caption{10 kiszállítási hely esetén az összehasonlítások száma: 68 594}
\label{fig:tsp10location}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{images/15.png}
\caption{15 kiszállítási hely esetén az összehasonlítások száma: 66 672}
\label{fig:tsp15location}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{images/20.png}
\caption{20 kiszállítási hely esetén az összehasonlítások száma: 65 265}
\label{fig:tsp20location}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{images/25.png}
\caption{25 kiszállítási hely esetén az összehasonlítások száma: 67 865}
\label{fig:tsp25location}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{images/30.png}
\caption{30 kiszállítási hely esetén az összehasonlítások száma: 65 324}
\label{fig:tsp30location}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{images/35.png}
\caption{35 kiszállítási hely esetén az összehasonlítások száma: 67 230}
\label{fig:tsp35location}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{images/40.png}
\caption{40 kiszállítási hely esetén az összehasonlítások száma: 66 008}
\label{fig:tsp40location}
\end{figure}

